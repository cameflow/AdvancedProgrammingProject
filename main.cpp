#include <iostream>
#include <SFML/Graphics.hpp>
#include <string>
#include <stdio.h>
#include <algorithm>    // std::shuffle
#include <array>        // std::array
#include <random>       // std::default_random_engine
#include <chrono>       // std::chrono::system_clock

// Definition of constants
#define SPEED_REEL_1 1
#define SPEED_REEL_2 3
#define SPEED_REEL_3 5
#define NUM_OF_REELS 4

// Struct for the imagesPrinted on the reel
struct reelImage {
  sf::Sprite sprite;
  int code;
};
// Struct for the reels
struct textureImage {
  sf::Texture texture;
  int code;
};

typedef void * (*spinFunctions) (void * arg);

// Definition of reels
textureImage reels[NUM_OF_REELS][8];
// Definition of temporary array
textureImage tempArray[8];
// Struct array
reelImage rImg[NUM_OF_REELS][3];
// Declaration of the mutex
pthread_mutex_t mutex_1 = PTHREAD_MUTEX_INITIALIZER;
// Array for shuffuled reel
std::array<int,8> imgs {1,2,3,4,5,6,7,8};

// Global control variables
bool roll = true;
bool anounceWinner = false;
bool play = true;

// ------ DECLARATION OF FUNCTIONS -------- //
void createReels();
void setSpritesOrigin();
void setSpritesPositions();
void shift(int pos, textureImage *arr);
void checkWin();
bool checkEqual(int arr[]);
// Creation of threads
void createThreads();
// Function that will make each reel spin
void * spinReel1(void * arg);
void * spinReel2(void * arg);
void * spinReel3(void * arg);
void * spinReel4(void * arg);
void * spinReel5(void * arg);
// Main function to show the game in the screen
void  drawGame();

sf::RectangleShape drawPlaybutton();
sf::RectangleShape drawStopbutton();
sf::Text drawStartText();
sf::Text drawStopText();
sf::Font font;

// Array of functions for when you create the threads
spinFunctions functions[] =
{
  spinReel1,
  spinReel2,
  spinReel3,
  spinReel4,
  spinReel5
};


int main(int argc, char const *argv[]) {

  // Game setup
  createReels();
  setSpritesOrigin();
  setSpritesPositions();
  //Start game
  drawGame();

  return 0;
}


// Seting the origin of the sprites to (0,0)
void setSpritesOrigin()
{
  for(int i = 0; i < NUM_OF_REELS; i++)
  {
    for(int j = 0; j < 3; j++)
    {
      rImg[i][j].sprite.setOrigin(0,0);
    }

  }
}

// Setting the position of the sprites
void setSpritesPositions()
{
  int x = 0;
  int y = 0;

  for (int i = 0; i < NUM_OF_REELS; i++)
  {
    for (int j = 0; j < 3; j++)
    {
      rImg[i][j].sprite.setPosition(sf::Vector2f(x,y));
      y += 250;
    }
    y = 0;
    x += 300;
  }

}

// Function to shift the array, it recieves a position and an array of textures
// First copies elements to a temp array
// Then returns the elements to the original array but moved an offset
void shift(int pos, textureImage *arr)
{
  int newpos;
  pthread_mutex_lock(&mutex_1);

  for (int j = 0; j < 8; j++)
  {
    tempArray[j] = arr[j];
  }

  // Iterate through the array and move it's conent to it's new position in the reel
  for (int i = 0; i < 8; i++)
  {
    newpos = i+pos;
    if(newpos < 8)
    {
      arr[i] = tempArray[newpos];
    }
    else if (newpos >= 8)
    {
      arr[i] = tempArray[newpos-8];
    }
  }
  // Unlock the mutex
  pthread_mutex_unlock(&mutex_1);

}

// Checks if the middle row is equal so you can win
// Firsts creates an array with the code of the elements in the middle row
// Then checks if all those codes are the same
void checkWin()
{
  int codes[NUM_OF_REELS];
  if(!anounceWinner)
  {
    bool isWinning = false;
    for (int i = 0; i < NUM_OF_REELS; i++)
    {
      codes[i] = rImg[i][1].code;
    }

    if(checkEqual(codes))
    {
      std::cout << "GANOOO" << '\n';
    }
    anounceWinner = true;
  }
}

// Create the threads and check for errors
// Uses an array of functions to create the threads
void createThreads()
{
  int status;
  pthread_t tid[NUM_OF_REELS];

  // Creation of threads
  // Error checking for threads
  for(int i = 0; i < NUM_OF_REELS; i++)
  {
    status = pthread_create(&tid[i], NULL, functions[i],NULL);
    if (status)
    {
      fprintf(stderr, "ERROR: pthread_create %d\n",status);
      exit(EXIT_FAILURE);
    }
  }
}

// Main function of the game that draws everything in the screen
void  drawGame()
{
  sf::RenderWindow window(sf::VideoMode(NUM_OF_REELS*300, 1000), "Test application");
  int cont = 1;
  createThreads();

  while (window.isOpen())
	{
		sf::Event event;
      // Wait for events generated by the window
		while (window.pollEvent(event))
		{
			if (event.type == sf::Event::Closed)
				window.close();
      // Check if key is pressed
      if (event.type == sf::Event::KeyPressed)
      {
        if (event.key.code == sf::Keyboard::S)
        {
          roll = false;
        }
        if (event.key.code == sf::Keyboard::R)
        {
          roll = true;
          anounceWinner = false;
        }
      }
      if (event.type == sf::Event::MouseButtonPressed)
      {
        if (event.mouseButton.button == sf::Mouse::Left)
        {
            if(event.mouseButton.x > 50 && event.mouseButton.x < 450 && event.mouseButton.y > 800 && event.mouseButton.y < 950)
            {
              roll = true;
              anounceWinner = false;
            }
            if(event.mouseButton.x > 450 && event.mouseButton.x < 850 && event.mouseButton.y > 800 && event.mouseButton.y < 950)
            {
              roll = false;
            }

        }
      }
		}

    // Clean the previous frame
		window.clear(sf::Color::White);

    pthread_mutex_lock(&mutex_1);

    // Add the texture to the sprite in the window


    for (int i = 0; i < NUM_OF_REELS; i++)
    {
      for (int j = 0; j < 3; j++)
      {
        rImg[i][j].sprite.setTexture(reels[i][j+3].texture);
        rImg[i][j].code = reels[i][j+3].code;
      }
    }



    // Draw all the sprites
    for (int i = 0; i < NUM_OF_REELS; i++)
    {
      for (int j = 0; j < 3; j++)
      {
        window.draw(rImg[i][j].sprite);
      }
    }
    window.draw(drawPlaybutton());
    window.draw(drawStopbutton());
    window.draw(drawStartText());
    window.draw(drawStopText());


    // If reels are not rolling check if you won
    if(!roll)
    {
      checkWin();
    }
    pthread_mutex_unlock(&mutex_1);
    // Display everything in the window
		window.display();
	}
  play = false;
  // return NULL;
  // pthread_exit(NULL);

}

// Function that will make the reel spin
void * spinReel1(void * arg)
{
  while (play)
  {
    if(roll)
    {
      shift(SPEED_REEL_1, reels[0]);
    }

  }

  return NULL;
}
void * spinReel2(void * arg)
{
  while (play)
  {
    if(roll)
    {
      shift(SPEED_REEL_2, reels[1]);
    }

  }

  return NULL;
}
void * spinReel3(void * arg)
{
  while (play)
  {
    if(roll)
    {
      shift(SPEED_REEL_3, reels[2]);
    }

  }

  return NULL;
}
void * spinReel4(void * arg)
{
  int index= 0;
  if (NUM_OF_REELS >= 4)
  {
    index = 3;
  }
  while (play)
  {
    if(roll)
    {
      shift(SPEED_REEL_3, reels[index]);
    }

  }

  return NULL;
}
void * spinReel5(void * arg)
{
  while (play)
  {
    if(roll)
    {
      shift(SPEED_REEL_3, reels[NUM_OF_REELS-1]);
    }

  }

  return NULL;
}

// Function that create the reels and fills them with images and codes
void createReels()
{
  for(int i = 0; i < NUM_OF_REELS; i++)
  {
    char file[10];
    unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
    shuffle (imgs.begin(), imgs.end(), std::default_random_engine(seed));
    for(int j = 0; j < 8; j++)
    {
      sprintf(file, "img-%d.png", imgs[j]);
      reels[i][j].texture.loadFromFile(file);
      reels[i][j].code = imgs[j];
    }
  }
}

// Checks if all the elements of an array are equal
bool checkEqual(int a[])
{
  for (unsigned i = 1; i < NUM_OF_REELS; i++)
  {
    if (a[i] != a[i-1])
    {
        return false;
    }
  }
  return true;
}

sf::RectangleShape drawPlaybutton()
{
  sf::RectangleShape start(sf::Vector2f(400, 150));
  start.setPosition(50,800);
  sf::Color color(150, 255, 150);
  start.setFillColor(color);
  return start;
}

sf::Text drawStartText()
{
  sf::Text text;

  if (!font.loadFromFile("Akashi.ttf"))
	{
		std::cout << "Could not load font!\n" << std::endl;
	}
  text.setFont(font);
	text.setString("START");
	text.setCharacterSize(90);
	text.setColor(sf::Color::Blue);
  text.setPosition(sf::Vector2f(100, 820));
  return text;
}
sf::Text drawStopText()
{
  sf::Text text;

  if (!font.loadFromFile("Akashi.ttf"))
	{
		std::cout << "Could not load font!\n" << std::endl;
	}
  text.setFont(font);
	text.setString("STOP");
	text.setCharacterSize(90);
	text.setColor(sf::Color::Blue);
  text.setPosition(sf::Vector2f(500, 820));
  return text;
}

sf::RectangleShape drawStopbutton()
{
  sf::RectangleShape start(sf::Vector2f(400, 150));
  start.setPosition(450,800);
  sf::Color color(255, 150, 150);
  start.setFillColor(color);
  return start;
}
