#include <iostream>
#include <SFML/Graphics.hpp>
#include <string>
#include <stdio.h>
#include <algorithm>    // std::shuffle
#include <array>        // std::array
#include <random>       // std::default_random_engine
#include <chrono>       // std::chrono::system_clock

// Definition of constants
#define SPEED_REEL_1 1
#define SPEED_REEL_2 3
#define SPEED_REEL_3 5

// Struct for the imagesPrinted on the reel
struct reelImage {
  sf::Sprite sprite;
  int code;
};
// Struct for the reels
struct textureImage {
  sf::Texture texture;
  int code;
};

// Definition of reels
textureImage reel1Textures[8];
textureImage reel2Textures[8];
textureImage reel3Textures[8];
// Definition of temporary array
textureImage tempArray[8];
// Struct array
reelImage reelImages[9];


// Array for shuffuled reel
std::array<int,8> imgs {1,2,3,4,5,6,7,8};

bool roll = true;
bool anounceWinner = false;
// Functions
void loadReeels();
void setSpritesOrigin();
void setSpritesPositions();
void shift(int pos, textureImage *arr);
void checkWin();
// Creation of threads
void createThreads();

int main(int argc, char const *argv[]) {
  sf::RenderWindow window(sf::VideoMode(900, 1000), "Test application");

  loadReeels();
  setSpritesOrigin();
  setSpritesPositions();

  int cont = 1;
  while (window.isOpen())
	{
		sf::Event event;
      // Wait for events generated by the window
		while (window.pollEvent(event))
		{
			if (event.type == sf::Event::Closed)
				window.close();
      // Check if key is pressed
      if (event.type == sf::Event::KeyPressed)
      {
        if (event.key.code == sf::Keyboard::S)
        {
          roll = false;
        }
        if (event.key.code == sf::Keyboard::R)
        {
          roll = true;
          anounceWinner = false;
        }
      }
		}

    // Clean the previous frame
		window.clear(sf::Color::White);


    reelImages[0].sprite.setTexture(reel1Textures[3].texture);
    reelImages[0].code = reel1Textures[3].code;
    reelImages[1].sprite.setTexture(reel1Textures[4].texture);
    reelImages[1].code = reel1Textures[4].code;
    reelImages[2].sprite.setTexture(reel1Textures[5].texture);
    reelImages[2].code = reel1Textures[5].code;
    reelImages[3].sprite.setTexture(reel2Textures[3].texture);
    reelImages[3].code = reel2Textures[3].code;
    reelImages[4].sprite.setTexture(reel2Textures[4].texture);
    reelImages[4].code = reel2Textures[4].code;
    reelImages[5].sprite.setTexture(reel2Textures[5].texture);
    reelImages[5].code = reel2Textures[5].code;
    reelImages[6].sprite.setTexture(reel3Textures[3].texture);
    reelImages[6].code = reel3Textures[3].code;
    reelImages[7].sprite.setTexture(reel3Textures[4].texture);
    reelImages[7].code = reel3Textures[4].code;
    reelImages[8].sprite.setTexture(reel3Textures[5].texture);
    reelImages[8].code = reel3Textures[5].code;


    for (int i = 0; i < 9; i++)
    {
      window.draw(reelImages[i].sprite);
    }


    if(roll)
    {
      shift(SPEED_REEL_1, reel1Textures);
      shift(SPEED_REEL_2, reel2Textures);
      shift(SPEED_REEL_3, reel3Textures);
    }
    else
    {
      checkWin();
    }

		window.display();
	}

  return 0;
}

void loadReeels()
{
  char file[10];
  unsigned seed = std::chrono::system_clock::now().time_since_epoch().count();
  shuffle (imgs.begin(), imgs.end(), std::default_random_engine(seed));

  for (int i = 1; i < 9; i++)
  {
    sprintf(file, "img-%d.png", 9-i);
    reel1Textures[i-1].texture.loadFromFile(file);
    reel1Textures[i-1].code = 9-i;
    sprintf(file, "img-%d.png", 9-i);
    reel2Textures[i-1].texture.loadFromFile(file);
    reel2Textures[i-1].code = 9-i;
    sprintf(file, "img-%d.png", imgs[i-1]);
    std::cout << imgs[i-1] << std::endl;
    reel3Textures[i-1].texture.loadFromFile(file);
    reel3Textures[i-1].code = imgs[i-1];
  }
}

void setSpritesOrigin()
{
  for(int i = 0; i < 9; i++)
  {
    reelImages[i].sprite.setOrigin(0,0);
  }
}

void setSpritesPositions()
{
  int x = 0;
  int y = 0;
  int cont = 0;
  for (int i = 1; i <= 3; i++)
  {
    for(int j = 1; j <= 3; j++)
    {
      reelImages[cont].sprite.setPosition(sf::Vector2f(x,y));
      y += 250;
      cont ++;
    }
    y = 0;
    x += 300;
  }
}

void shift(int pos, textureImage *arr)
{
  int newpos;

  for (int j = 0; j < 8; j++)
  {
    tempArray[j] = arr[j];
  }

  // Iterate through the array and move it's conent to it's new position in the reel
  for (int i = 0; i < 8; i++)
  {
    newpos = i+pos;
    if(newpos < 8)
    {
      arr[i] = tempArray[newpos];
    }
    else if (newpos >= 8)
    {
      arr[i] = tempArray[newpos-8];
    }
  }

}

void checkWin()
{
  if(!anounceWinner)
  {
    if (reelImages[1].code == reelImages[4].code && reelImages[7].code == reelImages[1].code)
    {
      std::cout << "YOU WON ON THE MIDDLE LINE" << std::endl;
    }
    anounceWinner = true;
  }

}


// Create the threads and check for errors
void createThreads()
{
  int status;
  pthread_t tid[NUM_THREADS];

  // Creation of threads
  // Error checking for threads
  status = pthread_create(&tid[0],NULL, &spinReel1,NULL);
  if (status)
  {
    fprintf(stderr, "ERROR: pthread_create %d\n",status);
    exit(EXIT_FAILURE);
  }
  status = pthread_create(&tid[1],NULL, &spinReel2,NULL);
  if (status)
  {
    fprintf(stderr, "ERROR: pthread_create %d\n",status);
    exit(EXIT_FAILURE);
  }
  status = pthread_create(&tid[2],NULL, &spinReel3,NULL);
  if (status)
  {
    fprintf(stderr, "ERROR: pthread_create %d\n",status);
    exit(EXIT_FAILURE);
  }
  status = pthread_create(&tid[3],NULL, &stopReel,NULL);
  if (status)
  {
    fprintf(stderr, "ERROR: pthread_create %d\n",status);
    exit(EXIT_FAILURE);
  }
}
